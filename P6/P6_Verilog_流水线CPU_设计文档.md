# 概述
---
由于本人非常菜，所以我在P6中分为下面这几个阶段：
1. 针对P5做出DM和IM的改进；
2. 新增P5已有的指令类型；
3. 增加乘除模块；
4. 思考题和测试方案。
# DM和IM改进
---
改进没什么好说的，看着教程来就可以了。
# 新增指令
---
按照P5，分为6种指令类型，其中需要修改的有：

| 指令类型 | 新增指令           | 修改部件        |
| -------- | ------------------ | --------------- |
| R型      | and、or、slt、sltu | Define、CU、ALU |
| I型      | addi、andi         | Define、CU、ALU |
| B型      | bne                | Define、CU、CMP |
| LS型     | lb、lh、sb、sh     | Define、CU                |
这个一步一步来，也十分简单。
# 乘除模块
---
## E_HILO
---
也是一个比较简单的算术单元，但是是时序逻辑。
端口定义：

| 端口   | 方向 | 位宽 | 描述         |
| ------ | ---- | ---- | ------------ |
| clk    | I    | 1    | 时钟信号     |
| reset  | I    | 1    | 复位信号     |
| rs     | I    | 32   | 运算数`rs`   |
| rt     | I    | 32   | 运算数`rt`   |
| opHILO   | I    | 4    | 操作类型     |
| HILObusy   | O    | 1    | 是否阻塞信号 |
| result | O    | 32   | 输出结果     | 
- 我们需要内置两个寄存器HI和LO，内置一个计数器，计算周期数；
- 还需要两个临时变量，用来临时储存乘除的结果；
- 这里尤其需要注意有符号数的处理方法，我们选择手动扩展，并且单独加变量；
## 修改
---
我们增添了乘除单元，那么就有许多模块需要进行修改；

| 修改模块 | 修改内容                                                                 |
| -------- | ------------------------------------------------------------------------ |
| CU       | CU中需要修改RegDataSel信号，多了乘除结果；并且还要修改RegAddr            |
| M、W_REG | 从E阶段开始要把乘除单元结果也随着流水级流下去                            |
| SU       | 因为乘除单元的出现，阻塞的需求更多了；并且还需要定义乘除信号的Tnew和Tuse |
| mips     | mips中的转发路径多了，并且实例化的时候多了几个信号                                                                         |

CU中我们将指令分为3类：

| 类型   | 需要的信号                    | 对应指令               |
| ------ | ----------------------------- | ---------------------- |
| TypeMd | E_opHILO                      | mult、multu、div、divu |
| TypeMf | E_opHILO, RegAddr, RegDataSel | mflo、mfhi             |
| TypeMt | E_opHILO                      | mtlo、mthi             |
# 思考题和测试方案
---
**1. 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？**

	因为乘除法部件需要多个周期才能执行完，但是ALU是组合电路，可以直接计算出结果，遵循“高内聚，低耦合”的设计思想，所以需要两个单元；
	因为HI和LO不是31个寄存器组中的寄存器，所以需要独立出来供MIPS使用；

**2. 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。**

	 1. MIPS乘法器：
	MIPS处理器的乘法器通常采用 Booth's 算法。Booth's 算法是一种基于二进制补码的乘法算法，通过将乘法操作分解为多个阶段，可以有效地实现流水线化。
	MIPS中的乘法器可能包括以下阶段：
	 乘法操作数获取：从寄存器文件中获取乘法指令中的操作数。
	 Booth's 算法执行： 将乘法操作数送入乘法器执行 Booth's 算法的阶段。
	 部分积累加：通过多个时钟周期逐步累加部分积。
	 结果保存：将最终结果保存到目标寄存器中。
	  2. MIPS除法器：
	MIPS处理器的除法器通常采用迭代除法算法，例如 SRT（SrtRestoring Division）算法。这种算法通过逐步逼近商来执行除法操作。
	MIPS中的除法器可能包括以下阶段：
	除法操作数获取：从寄存器文件中获取除法指令中的被除数和除数。
	迭代除法执行：将除法操作数送入除法器执行迭代除法算法。
	商累加：通过多个时钟周期逐步累加商。
	余数更新：更新余数，以便进行下一轮迭代。
	结果保存：将商保存到目标寄存器中。

**3. 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？**

	我是通过内置一个计数器count，当遇到乘法指令时，count为5；当遇到除法指令时，count为10；当count不为0时，输出busy信号，当遇到乘除这八条指令时，进行阻塞；如果没有遇到乘除指令，那么每个周期count-1；并且如果遇到乘除法时，start置为1，当count不为零或者start不为0时，busy为1.
	在阻塞电路SU里，我们通过译码译出D阶段的指令，如果为乘除指令并且乘除单元传来了Busy信号，那么就进行阻塞。

**4. 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）**

	清晰性：采用独热编码，非常清晰的表明了我们需要取这个字的哪个字节；
	统一性：4位编码，可以保证每一种字节存储都能够保证满足；

**5. 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？**

	不是一个字节，因为我们写入的数据永远都是rt寄存器的第一个字节，而获取的数据可能是DM的四个字节的任意一个。
	当我们的DM是字节对齐的时候，也就是每一个DM单元对应一个8位的数据时，字节读和字节写效率高。

**6. 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？**

	首先，我们的CU非常的复杂，我选择的是设计一个总的CU，在不同的阶段或者不同的时刻进行译码；这样的抽象方式让我们更能够清晰地明白一条指令对应的特点特征是什么，并且我们只需要提取这个阶段它需要的特征即可；这样的方式使得我在SU阻塞的时候非常方便，并且我的代码可读性也大大提高；
	其次，我也对乘除单元等等部件进行了抽象，尽可能地减少这些部件的复杂度，使得他们都能够作为一个独立的系统单元，并且能够和外部链接。这样的话使得我们更加清晰地了解CPU的每个部件的作用。
	最后，我在真正实现的时候，先是进行了指令的分类，随后又进行了CPU的图的画，使得我对CPU的认识更加清晰。

**7. 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？**

	我在实验中没有遇到过冲突问题，我就是用基本的AT法计算解决阻塞转发问题的。并没有单独为阻塞测试样例。

**8. 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。**

	我觉得还是主要考虑到了跳转指令和延迟槽，因为跳转指令默认就需要进行阻塞，否则绝对是错误的，所以仅仅测一测跳转指令就ok了。
	其次，我的数据和P4差不多，只不过再每个跳转指令时，我都选择延迟槽是否实现。因为P4的延迟槽没有实现，所以按照没有延迟槽的代码逻辑，和加了延迟槽的逻辑都跑一遍，最后对比一下在MARS中运行的结果就可以了。
	我觉得可以从指令分类的角度考虑，然后不同类别相互组合。

``` MIPS
lui $t1, 0xffff
ori $t1, 0xfffe
ori $t0, 2
lui $ra, 0xffff
ori $ra, 0xffff
jal function
add $t4, $t1, $t1
sw $t4, 0($0)
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_1_begin:
beq $s0, $s1, for_1_end
nop
	add $s5, $s0, $s5
add $s0, $s0, $s2
nop
jal for_1_begin
## nop
for_1_end:
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_2_begin:
beq $s0, $s1, for_2_end
nop
	add $s6, $s0, $s6
	jr $ra
add $s0, $s0, $s2
nop
jal for_2_begin
nop
for_2_end:
beq $s6, $s5, end
beq $s0, $s6, end
beq $s6, $s2, end
beq $s0, $s2, end
beq $0, $7, end
function:
lui $t2, 0xffff
ori $t2, 0xfffe
ori $t3, 2
lui $t4, 0xffff
ori $t4, 0xffff
beq $t1, $t2, jump
## nop 这个nop不加会出错误
lui $ra, 0
ori $ra, 0
jump:
sub $t4, $t4, $t1
beq $t4, $t1, function
## nop 这个nop不加还会有错，可能是延迟槽出现了跳转指令
jr $ra
end:
##nop  这个nop不加也会出错
```

# 课上考试
---
首先可以参考P5写的：

1. 考前准备
	- 课上千万别急，先稳住心态，深呼吸，看好电路图；
	- 先用ISE创建几个工程项目，并且创建一个test文件；
	- 考试开始后，先阅读考试说明，查看指令集，下载zip文件，下载每一个指令的class并且导入mars；
	- 将zip解压缩之后修改SU中的阻塞，再提交到三个指令中，看看有没有课下错误，有课下错误先de课下错误；
	- 然后先把错误代码写到纸上，随后开始分析正是写题。
2. 计算类（R or I）
	1. 首先，先在宏定义中加上指令译码，一定不要进行归类（如果有条件写的话），并且在ALUout中加入操作信号；
	2. 然后，在CU中进行改变，output加一个这样的指令名称，并且选择他需要的信号；
	3. 如果没有条件写，那可以直接秒了；
3. 跳转类（B + jl）
	1. 首先，宏定义加上指令译码，加一个opCMP信号，然后在CU中进行改变，往往opEXT可以归类，opBranch也可以；
	2. 其次，注意他可能有写回PC8的指令，那么我们可以加一个check信号，和Bflag信号值一样，并且通过流水传下去（需要在草图上表示清楚）；
	3. 最后，改变CU的Reg类操作，WE一定是1，但是写入的可能是0号寄存器（也就是不写不转发），DataSel是PC8（如果写的话）；
4. 访存类（L or S + condition）
	1. 首先，宏定义加上指令译码，看看访存的类型，然后在CU中改变opEXT，ALUsrcB，loadtype或storetype，还有DMWE；
	2. 其次，如果是条件加载，也就是可能加载也可能不加载，那么我们在判断SU的时候，要把这条指令译码出来，并且把如果可能冲突就阻塞，直到判断出真的写不写之后，也就是说在E阶段需要加一个保守的阻塞信号；
	3. 最后，流传下去的方法和跳转类一样；
5. 考试心态
	1. 心态一定要平稳，读三遍题再写，千万别把题目看错；
	2. 加油，你一定可以成功的！加油！
其次，对于P6，我又单独加了一部分：
1. 一定要小心`$signed()`;