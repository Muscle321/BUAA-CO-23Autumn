# Verilog搭建CPU
---
Verilog设计CPU，就更加抽象了，我选择自顶向下设计CPU的方式进行设计，因为在P3，已经把实体化电路搭建完毕，所以我觉得P4就可以照着P3的进行翻译即可。
我的设计文档分为下面这几部分：
1. CPU模块化过程
2. CPU组装过程
3. 自己测试CPU过程
4. 思考题
5. 新增指令

## 模块化过程
---
我们包括取指令模块（IFU、NPC），控制器模块（Controller）和执行部件（ALU、EXT、DM、GRF等等）

### 取指令模块
---
#### 地址计算器（NPC）
---
模块接口：

| 端口   | 方向 | 位宽 | 描述                                 |
| ------ | ---- | ---- | ------------------------------------ |
| PC     | I    | 32   | 本周期的指令地址                     |
| Branch | I    | 32   | 跳转指令地址或者需要传入计算的跳转值 |
| opNPC  | I    | 3    | 选择执行指令地址计算方案             |
| NPC    | O    | 32   | 下一周期的指令地址                                     |
opNPC种类：

| 控制信号 | 编码 | 描述                           | 指令列举   |
| ---------- | ---- | ------------------------------ | ---------- |
| Normal     | 000    | PC + 4                         | 几乎所有   |
| JImm     | 001    | PC + 4 + ($signed(branch))<<2    | beq、bne等 |
| JIndex          | 010    | {PC[31:28], branch[25:0], 0,0} | j、jal     |
| JReg         | 011    | branch                         | jalr、jr   |
- 至于为什么opNPC做成3为，是为了方便课上的其他类型跳转指令的实现；
- NPC是组合逻辑电路，用`assign`即可实现目标；

#### 取指令单元（IFU）
---
模块接口：

| 端口  | 方向 | 位宽 | 描述             |
| ----- | ---- | ---- | ---------------- |
| clk   | I    | 1    | 时钟周期         |
| reset | I    | 1    | 同步复位信号     |
| NPC   | I    | 32   | 下一周期指令地址 |
| Instr | O    | 32   | 输出的指令       |
| PC    | O    | 32   | 这一周期的指令地址                 |
- 对于储存指令的模块我们采用数组来进行储存;
``` Verilog
	reg [31:0] IM [0:4095];
	initial begin
        $readmemh("code.txt", IM);
	end
```
- 对于PC，我们的处理方式和Logisim中的一样，储存IM对应的PC，输出时再转换为MIPS中的PC；
- 这是一个时序逻辑电路，需要再always块中寄存下一周期指令地址。

### 执行部件
---
#### 寄存器文件（GRF）
---
模块接口：

| 端口  | 方向 | 位宽 | 描述                        |
| ----- | ---- | ---- | --------------------------- |
| clk   | I    | 1    | 时钟信号                    |
| reset | I    | 1    | 同步复位信号                |
| WE    | I    | 1    | 写使能信号                  |
| A1    | I    | 5    | 第一个reg地址               |
| A2    | I    | 5    | 第二个reg地址               |
| A3    | I    | 5    | 可能需要写入的第三个reg地址 |
| WD    | I    | 32   | 写入寄存器的数据            |
| PC    | I    | 32   | 评测机测试使用                            |
| RD1   | O    | 32   | 读出第一个reg的数据         |
| RD2   | O    | 32   | 读出第二个reg的数据         |
- 我们仍然采用数组储存32个寄存器；
- 这仍然是一个时序逻辑电路，需要考虑同步复位的处理；
- 需要注意的是，0号寄存器不可以被写入并且始终为0。

#### 算术逻辑单元（ALU）
---
模块接口：

| 端口      | 方向 | 位宽 | 描述                   |
| --------- | ---- | ---- | ---------------------- |
| SrcA      | I    | 32   | 第一个运算数           |
| SrcB      | I    | 32   | 第二个运算数           |
| op_ALU    | I    | 3    | 运算类型               |
| ALUResult | O    | 32   | 运算结果               |
| Zero      | O    | 1    | ALUResult是否为0的判断               |
ALU运算类型：

| 信号  | 编码 | 描述           |
| ----- | ---- | -------------- |
| add   | 000    | 32位无符号加法 |
| sub   | 001    | 32位无符号减法 |
| oor    | 010    | 32位或运算     |
| sll16 | 011    | 移位运算       |
- 由于指令集中基础的运算类型实在是太多，补充那么多指令也实属折磨，所以目前就仅仅过了课下的指令即可。

#### 扩展单元(EXT)
---
端口定义：

| 端口      | 方向 | 位宽 | 描述                   |
| --------- | ---- | ---- | ---------------------- |
| imm       | I    | 16   | 16位立即数             |
| opEXT     | I    | 1    | 扩展信号               |
| EXT       | O    | 32   | 扩展后的结果                       |
- 我不在EXT中进行其他移位等操作，我将移位操作放在了ALU或者NPC中，扩展器就只进行扩展。
#### 数据储存期(DM)
---
模块接口：

| 端口  | 方向 | 位宽 | 描述                            |
| ----- | ---- | ---- | ------------------------------- |
| clk   | I    | 1    | 时钟信号                        |
| reset | I    | 1    | 通步复位信号                    |
| WE    | I    | 1    | 是否写信号                      |
| WD    | I    | 32   | 写入的数据                      |
| addr  | I    | 32   | 输入的地址（需要转换为RAM地址） |
| PC    | I    | 32   | 测试用                                |
| RD    | O    | 32   | 读出的数据                      |
- 这是一个时序逻辑电路，我们仍然采用数组储存来作为DM；
- 因为课下并没有涉及字节存或者读，在此先不实现；

### 控制器部件(Controller)
---
下面是本次课上所需要的控制信号：

| 控制信号类型   | 描述                                                                           | 使用者                         |
| -------------- | ------------------------------------------------------------------------------ | ------------------------------ |
| NumRead        | 是否读出DM中的数据                                                             | 特定用，主要为lw等取数据指令   |
| NumWrite       | 是否向DM中写入数据                                                             | 特定用，主要为sw等存数据指令   |
| opNPC[2:0]     | 控制下一条指令地址的计算方式                                                   | 特定用，主要为跳转指令         |
| opALU[2:0]     | 控制ALU进行的操作                                                              | 公用，主要为涉及逻辑运算的指令 |
| ALUsrc         | 选择第二个ALU操作数SrcB是立即数还是寄存器中的值                                | 公用，主要为i型指令            |
| opExt         | 立即数扩展选择符号扩展(1)还是零扩展(0)                                         | 公用，涉及扩展数字的指令       |
| RegWrite       | 是否可以写入寄存器                                                             | 公用，涉及存入寄存器的指令     |
| RegSel         | 选择写入哪个寄存器，是rt(值为0)(i型指令)还是rd(值为1)(R型指令);若不写入，则为0 | 公用，主要为R型指令            |
| isJAL          | 选择是否写入31号寄存器                                                         | 私用，jal指令                  |
| BranchSel[1:0] | 选择输入Branch信号                                                                 | 特定用，跳转指令                               |
- 对于特定用寄存器，一般也是私用，有扩展信号的时候考虑是否要改变，一定要考虑改变该控制信号对原有指令的影响！！！
- 对于私用控制信号，就是控制单个指令的进行，主要用于扩展信号使用。

下面是本次课下用到的控制信号与操作的对应关系：

|            |         |         |         |         |         |         |         |         |         |
| ---------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| opcode     | 00_0000 | 00_0000 | 00_1101 | 10_0011 | 10_1011 | 00_0100 | 00_1111 | 00_0011 | 00_0000 |
| funct      | 10_0000 | 10_0010 |         |         |         |         |         |         | 00_1000 |
| Instr_type | add     | sub     | ori     | lw      | sw      | beq     | lui     | jal     | jr      |
| NumRead    | 0       | 0       | 0       | 1       | x       | x       | 0       | 0       | 0       |
| NumWrite   | 0       | 0       | 0       | 0       | 1       | 0       | 0       | 0       | 0       |
| opNPC[2:0]      | 0       | 0       | 0       | 0       | 0       | 1       | 0       | 2       | 3       |
| opALU[2:0]      | 0       | 1       | 2       | 0       | 0       | 1       | 3       | 0       | 0       |
| ALUsrc     | 0       | 0       | 1       | 1       | 1       | 0       | 1       | 0       | 0       |
| opExt     | 0       | 0       | 0       | 1       | 1       | 1       | 0       | 0       | 0       |
| RegWrite   | 1       | 1       | 1       | 1       | 0       | 0       | 1       | 1       | 0       |
| RegSel     | 1       | 1       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| isJAL      | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 1       | 0       |
| BranchSel[2:0]  | 0       | 0       | 0       | 0       | 0       | 1       | 0       | 2       | 3        |
- 输入仅仅输入一个PC值即可，其余用组合逻辑实现controller；
- 在进行扩展指令的时候，一定要注意不要在已有的私有信号上进行改变，尽量增加其特有信号。

## CPU组装过程
---
1. 首先，我们注意哪个部件是状态储存功能，哪个部件是状态转移功能，我们要先把这些分清楚；
	1. 状态储存：IFU、GRF、DM
	2. 状态转移：NPC、ALU、EXT、Controller
2. 其次，我们要搞清楚每个部件的接口的定义，先声明各个线再进行连接，一定要搞清楚接的是哪个数据端，一定是对应的数据端才能连接；
3. 然后，开始连线，连接多路选择器等等部件；
4. 最后，就是实例化的过程。


## CPU测试方案
---
我的测试比较简单，主要考虑到新增指令`jal、jr`这两个指令，因为其他指令我没有进行太多的考虑，因为比较基础，一旦有错误，这些都不能执行，我的示例代码：
```
lui $t1, 0xffff
ori $t1, 0xfffe
ori $t0, 2
lui $ra, 0xffff
ori $ra, 0xffff
jal function
add $t4, $t1, $t1
sw $t4, 0($0)
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_1_begin:
beq $s0, $s1, for_1_end
nop
	add $s5, $s0, $s5
add $s0, $s0, $s2
nop
jal for_1_begin
for_1_end:
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_2_begin:
beq $s0, $s1, for_2_end
nop
	add $s6, $s0, $s6
	jr $ra
add $s0, $s0, $s2
nop
jal for_2_begin
for_2_end:
beq $s6, $s5, end
beq $s0, $s6, end
beq $s6, $s2, end
beq $s0, $s2, end
beq $0, $7, end
function:
lui $t2, 0xffff
ori $t2, 0xfffe
ori $t3, 2
lui $t4, 0xffff
ori $t4, 0xffff
beq $t1, $t2, jump
lui $ra, 0
ori $ra, 0
jump:
sub $t4, $t4, $t1
beq $t4, $t1, function
jr $ra
end:
```
通过两个for循环，第一个考虑jal是否正常跳转，第二个考虑jal是否写入寄存器。

## 思考题
---
1. **阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？**
![[Pasted image 20231103211608.png]]
这个addr信号目前的指令都来自于ALUresult，因为addr都需要进行ALU运算才能计算得到结果；
因为addr是cpu里的地址，是按字节存储的，而DM中是按字也就是四个字节存储的，所以我们的addr一定是4的倍数，并且对于取字指令，只需要取[11:2]位即可；
2. **思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。**
对于**指令对应的控制信号如何取值**这一方式，示例代码:
``` verilog
always@(*) begin
	if(`add) begin
		ALUop = 3'b001;
		ALUsrc = 1;
	end
	else if (`sub) begin
		ALUop = 3'b010;
		ALUsrc = 1;
	end
end
```
对于**控制信号每种取值所对应的指令**这一方式，示例代码：
``` verilog
	 assign ALUsrc = (opcode == `ori) ? 1 :
						  (opcode == `lw) ? 1 :
						  (opcode == `sw) ? 1 :
						  (opcode == `lui) ? 1 : 0;
						  
	 assign RegWrite = (opcode == `ori) ? 1 :
							 (opcode == `lw) ? 1 :
							 (opcode == `jal) ? 1 :
						    (opcode == `lui) ? 1 : 
							 (opcode == `typeR && funct == `add) ? 1 : 
							 (opcode == `typeR && funct == `sub) ? 1 : 0;
```
对于第一种方式，简单明了能够看出每种指令对应的控制信号，更容易进行扩展指令，但是可能会出现控制信号未重置的错误；第二种方式，更加清晰的明确了各种控制信号，并且避免了某些控制信号在本周期是未知值的可能，但是新增指令的时候不太方便；
3. **在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。**
同步复位中clk优先级比reset高，因为如果clk不为1，reset不起作用；
异步复位中reset优先级比clk高，只要reset为1，无论clk的值，均需要进行复位。
4. **C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读[《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》](http://cscore.buaa.edu.cn/assets/cscore-assets/MIPS_Vol2_%E6%8C%87%E4%BB%A4%E9%9B%86_.pdf)中相关指令的 Operation 部分（详见文档 page 34、page 35）。**
在ADD指令中：
![[Pasted image 20231103213051.png]]
我们可以知道，如果没有溢出，那么addu和add等价，add仅仅多了一个溢出检测；addi与addiu等价。


## 新增指令
---
我觉得普通的R型I型指令没有什么可扩展的并且会徒增复杂度，所以我进行扩展的跳转指令有`j、jalr`，存取指令有`lb,sb,lh,sh`，并且我也不是完全的进行扩展，我只是在对应模块`NPC`和`DM`中加了一些控制信号，控制这些数据的生成，毕竟`opcode`不一样，在课上考试遇到类似的情况直接使用即可。
~~毕竟拓展指令也只是为了过课上~~
