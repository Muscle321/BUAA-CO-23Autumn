# 流水线CPU
---
由于本人非常菜，流水线对本人造成了很大的困扰，所以我在设计流水线CPU和单周期不同，分为下面这几个阶段：
1. 理解流水线的意义，先进行理论研究各个阶段需要的部件；
2. 分析清楚可能出现的各种冒险；
3. 开始搭建CPU，主要是控制器和各个阶段传输数据的搭建；
4. 思考题和测试方案。

## 流水线概述
---
流水线CPU，本质上还是一种CPU，也是要处理指令的，要经过取指令和执行指令过程。但是取指令我们也包括好几部分，总之，我们把CPU功能分为四部分，即取指阶段、译码阶段、执行阶段和存储阶段，为了方便最后又加了一条写回寄存器阶段。
流水线阶段：

| 阶段            | 简称 | 功能                                                   | 
| --------------- | ---- | ------------------------------------------------------ |
| 取指(Fetch)     | F    | 从指令存储器中读取指令                                 |
| 译码(Decode)    | D    | 从寄存器文件中读取源操作数并对指令译码以便得到控制信号 |
| 执行(Execute)   | E    | 使用ALU执行计算                                        |
| 存储(Memory)    | M    | 读或写数据寄存器DM                                     |
| 写回(Writeback) | W    | 将结果写回寄存器                                       |


我查阅了指令集架构，我们要对指令进行执行，那么不同指令可能需要CPU做到的功能也不太相同，分为R型运算类型，I型立即数运算类型，J型跳转型，B型跳转标签型，L型加载数据，S型保存数据这六类。我们将分别从这六类寄存器的特点出发，研究这六类寄存器所需要的操作。

### R型运算指令
---
R型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作               | 传输到下一阶段的数据    | 控制信号         |
| ---- | ------------------------ | ----------------------- | ---------------- |
| F    | 取指令                   | Instr、F_PC             |                  |
| D    | 读出`rs`、`rt`寄存器的值 | rs、rt、Instr、D_PC |                  |
| E    | 执行ALU运算              | ALUresult、Instr、E_PC  | opALU[3:0]       |
| M    | 无                       | ALUresult、Instr、M_PC  |                  |
| W    | 将结果写入`rd`寄存器中   |                         | RegSel、RegWrite |

### I型运算指令
---
I型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作                               | 传输到下一阶段的数据  | 控制信号         |
| ---- | ---------------------------------------- | --------------------- | ---------------- |
| F    | 取指令                                   | Instr、F_PC                 |                  |
| D    | 读出`rs`寄存器的值，读出立即数并进行扩展 | rs、Imm、 Instr、D_PC | opExt                |
| E    | 执行ALU运算                              | ALUresult、Instr、E_PC      | opALU[3:0]、ALUsrc        |
| M    | 无                                       | ALUresult、Instr、M_PC      |                  |
| W    | 将结果写入`rt`寄存器中                   |                       | RegWrite |

### B型跳转标签型
---
B型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作                                     | 传输到下一阶段的数据       | 控制信号  |
| ---- | ---------------------------------------------- | -------------------------- | --------- |
| F    | 取指令                                         | Instr、F_PC                     |           |
| D    | 读出`rs`、`rt`寄存器的值，读出立即数并进行扩展 | Branch，opNPC传到F阶段 | opNPC，opExt |
| E    | 无                                             |                            |           |
| M    | 无                                             |                            |           |
| W    | 无                                             |                            |           |
- 采用直接在D阶段进行B型指令的判断的好处就是，提前分支判断；

### J型跳转型
---
J型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作                 | 传输到下一阶段的数据                   | 控制信号         |
| ---- | -------------------------- | -------------------------------------- | ---------------- |
| F    | 取指令                     | Instr、F_PC              |                  |
| D    | 进行译码判断是否要写入PC+4 | Branch，opNPC传到F阶段，PC传到下一阶段 | opNPC，opExt     |
| E    | 无                         | Instr、PC                                       |                  |
| M    | 无                         |   Instr、PC                                     |                  |
| W    | 可能是否写入PC+4           | Instr、PC                                   | RegWrite、opLink | 

### L型加载数据
---
L型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作                               | 传输到下一阶段的数据     | 控制信号      |
| ---- | ---------------------------------------- | ------------------------ | ------------- |
| F    | 取指令                                   | Instr、F_PC              |               |
| D    | 读出`rs`寄存器的值，读出立即数并进行扩展 | Imm、rs、 Instr、D_PC | opExt|
| E    | 执行ALU运算                              | ALUresult、Instr、E_PC   | opALU[3:0]、ALUsrc     |
| M    | 读出DM中对应地址的值                     | DM_result、Instr、M_PC   | NumRead、ReadType              |
| W    | 将结果写入`rt`寄存器中                   |                          | RegWrite      |

### S型保存数据
---
S型指令各个阶段的操作及需要传输的数据：

| 阶段 | 进行的操作                               | 传输到下一阶段的数据     | 控制信号      |
| ---- | ---------------------------------------- | ------------------------ | ------------- |
| F    | 取指令                                   | Instr、F_PC              |               |
| D    | 读出`rs`寄存器的值，读出立即数并进行扩展 | Imm、rs、DM_WD、Instr、D_PC | opExt|
| E    | 执行ALU运算                              | ALUresult、DM_WD、Instr、E_PC   | opALU[3:0]、ALUsr    |
| M    | 将`rt`的数据写入对应地址中               | Instr、M_PC   | NumWrite、WriteType      |
| W    | 无                                         |                          |               |

### 综述
---
至此，我们每一条指令对应的操作基本都已经了解，那么我们还需要归纳总结，流水线的各个阶段，需要传入的各种数据，所包含的各种类型信号等等。

| 阶段 | 所包含部件                    | 控制信号                                         | 传到下一阶段的数据                                 |
| ---- | ----------------------------- | ------------------------------------------------ | -------------------------------------------------- |
| F    | IFU                      | opNPC(D阶段传入)[1:0]                            | Instr、PC                                          |
| D    | NPC、GRF、EXT、CMP(B型指令用)、CU1 | opNPC[1:0]、ALUsrc、opExt                        | Instr、PC、SrcA、SrcB、DM_WD、opNPC和Branch(传到F) |
| E    | ALU、CU2                      | opALU[3:0]                                       | Instr、PC、DM_WD、ALUresult                        |
| M    | DM、CU3                       | NumWrite、NumRead、ReadType[2:0]、WriteType[2:0] | Instr、PC、Result                                  |
| W    | GRF、CU4                      | RegSel、RegWrite、opLink                         |                                                    |

## 冒险类型及判断
---
冒险包括三种类型，结构冒险、控制冒险、数据冒险。我将分别从这三种冒险进行分析，将流水线CPU更加完善。

### 结构冒险
---
结构冒险在我们设计的CPU中只有寄存器读写冒险。我们在D和W阶段如果同时对一个寄存器进行读写操作，那么就会出现错误。

我们采用内部转发的策略，即：当写入和读出的寄存器地址相同时，我们需要将即将写入的信号读出。
### 控制冒险
---
控制冒险容易理解，就是我们在顺序执行指令的时候，可能会出现跳转指令的进行，那么就会导致一些指令错误被计算。所以我们将是否跳转放在了D阶段进行判断，这样就会有一个周期的延迟槽的存在，由于我们不需要任何改进，所以这个冒险就不需要任何行为进行解决。

我们需要实现的只有在`jal`指令中将`PC+8`传下去，存到`$31`寄存器即可，其余不需要任何改变。

### 数据冒险
---
最最最复杂，最难理解的数据冒险要来力。
数据冒险的意思也就是我们接下来的指令需要用到的寄存器还没有被写入数据，所以我们读出来的数据不是正确数据，我们有两种解决方法，一种是阻塞，一种是转发。我将分别描述这两种方法。
#### 阻塞
---
阻塞非常好理解，就是最简单的在E级流水级加入一个`stall`信号，如果停止，那么就将下一条指令改为`nop`就像插入一个气泡一样。这就需要在添加一个阻塞判断单元，来决定是否停止在D级，注意此时F级的PC也要停止。那么我们就可以把NPC的计算单元转移到D级中去，就不需要再在F级中进行判断了。

#### 转发
---
转发有很多种情况，但是我们的转发情况也不算很多，归结来说，就是下一阶段的指令用到的寄存器还没有被上一阶段的指令写入，但是已经计算完成了，那么我们可以通过转发电路来实现该条件。
也就是说我们增加一个多路选择器，使得如果允许转发，我们就把计算出来的值直接进入到该指令进行运算，大大节省了性能。

#### 阻塞和转发的判断
---
参考教程中的AT模型计算。

A模型比较好理解，就是如果写入的寄存器和你要用的都不一样，那就没有必要转发，直接读就可以了；所以A模型可以理解为判断要用的寄存器是否为**上一周期已经算出来但是没有来得及写入的**。

T模型就是计算我们在这一周期能不能通过转发实现，还是说必须阻塞一周期；
有两个概念，一个是`Tuse`，一个是`Tnew`；顾名思义，前者，就是我们还要多少周期就要使用这个寄存器了，这个值是在译码的时候就已经生成的固定不变的；后者，就是我们还有多少周期就可以计算出这个寄存器要写的值（指存入流水级的时间）了，这个肯定是随着周期的进行不断递减的，我们规定它大于等于0，并且当他等于0时，代表已经计算完成了，并且存入流水级了。

需要注意的是，我们的时间计算都是从D级流水级开始计算的周期，下面将分别写出这6类指令的`rs`和`rt`的`Tuse`和不同阶段的`Tnew`值。

| 指令类型 | Tuse_rs | Tuse_rt | Tnew_E | Tnew_M |
| -------- | ------- | ------- | ------ | ------ |
| R型      | 1       | 1       | 1      | 0      |
| I型      | 1       | 无      | 1      | 0      |
| B型      | 0       | 0       | 无     | 无     |
| J型      | 0       | 无      | 0      | 0      |
| L型      | 1       | 无       | 2      | 1      |
| S型      | 1       | 2       | 无     | 无      |

在每一个D阶段，我们需要判断AT模型：
如果A相等，当Tnew>Tuse时，那么必须暂停；反之，可以转发实现。
这就需要再加一个单元使判断转发。

## 搭建CPU
---
接下来就开始大工程搭建CPU了，在搭建CPU之前，我觉得还是要理清楚需要的各个部件之间的关系：
![[CPU 1.jpg]]
（D阶段少了个D_EXT）~~但是不想改了~~
下面我们一个一个部件来搭，不着急^ ^
- 因为已经做过了P3，P4，所以直接搭CU是可以接受的，而且我的译码是分支译码，但是却是所有的阶段公用一个CU，在每个阶段对CU分别进行实例化即可；
- 其次把新学的也是最恶心的SU和FU搞定，那么剩下的就不是什么难事了。

### Define
---
我们先把宏定义全部写出来，每个部件要的宏定义，全部包含在这里。
- 首先是控制信号需要的宏，
- 其次是各个基础部件依次需要的宏；
- 最后是主电路可能涉及的宏。

### CU
---
- 我们的控制器是分支控制器，用一个总的控制器；
- 每个阶段需要分别对CU进行实例化获得这个阶段需要的控制信号就可以了；
- 为了FU和SU，我们还需要进行判断这条指令是哪种类型的，所以需要加控制信号；
- 我们首先定义多条`wire`型变量，方便译码的进行；
- 我们在选择控制信号的时候，要先进行分类，找到该指令的类型，然后再判断需要的控制信号；
- 最后迫不得已，再选择几个私有信号的判断；
接下来我们将写出需要的控制信号：（初步套用P4）

| 控制信号类型     | 描述                         | 使用者                     | 阶段   |
| ---------------- | ---------------------------- | -------------------------- | ------ |
| D_opNPC[2:0]     | 控制下一条指令地址的计算方式 | TypeB、TypeJ               | D      |
| D_opExt[1:0]     | 立即数扩展选择               | TypeI、TypeS、TypeL、TypeB | D      |
| D_opBranch[2:0]  | CMP选择                      | TypeB                      | D      |
| E_opALU[3:0]     | 控制ALU进行的操作            | TypeR、TypeI               | E      |
| E_ALUsrcA[1:0]   | 选择SrcA                     | TypeR                      | E      |
| E_ALUsrcB[1:0]   | 选择SrcB                     | TypeR、TypeI               | E      |
| M_loadType[2:0]  | load类型                     | TypeL                      | M      |
| M_storeType[1:0] | Store类型                    | TypeS                      | M      |
| M_DMWE          | 是否向DM中写入数据           | TypeS                      | M      |
| W_regWrite       | 是否可以写入寄存器           | TypeR、TypeI、TypeL、jl        | W      |
| RegAddr[4:0]     | 选择写入寄存器地址rt、rd、31 | TypeR、TypeI、TypeL、jl              | 全过程 |
| RegDataSel[1:0]  | 选择数据写入寄存器           | TypeR、TypeI、TypeL、jl           | 全过程       |

### FU
---
FU单元是判断进行转发哪个数据的信号，我们进行转发是**寄存器**需要使用新值，但是还没有写入的时候我们才进行转发，所以在每一个需要使用寄存器的单元之前，我们进行转发就可以了。
我们可以看出：
- 在D阶段，CMP需要`rs`和`rt`，NPC需要`rs`；
- 在E阶段，ALU需要`rs`和`rt`；
- 在M阶段，DM需要`rt`;
其他阶段都没有，那么我们就需要通过DEMW四个阶段指令来判断我们转发的信号。

| 端口     | 方向 | 位宽 | 描述      |
| -------- | ---- | ---- | --------- |
| D_Instr  | I    | 32   | D阶段指令 |
| E_Instr  | I    | 32   | E阶段指令 |
| F_Instr  | I    | 32   | F阶段指令 |
| W_Instr | I    | 32   | W阶段指令     |
| D_pre_rs | I    | 32   | D阶段初始`rs`值          |
| D_pre_rt | I    | 32   | D阶段初始`rt`值          |
| E_pre_rs | I    | 32   | E阶段初始`rs`值          |
| E_pre_rt | I    | 32   | E阶段初始`rt`值          |
| M_pre_rt | I    | 32   | M阶段初始`rt`值          |
| E_RegData  | I    | 32   | E阶段传入数据 |
| M_RegData  | I    | 32   | M阶段传入数据 |
| W_RegData  | I    | 32   | W阶段传入数据 | 
| D_rs    | O    | 32   | D阶段`rs`寄存器数据 |
| D_rt    | O    | 32   | D阶段`rt`寄存器数据 |
| E_rs    | O    | 32   | E阶段`rs`寄存器数据 |
| E_rt    | O    | 32   | E阶段`rt`寄存器数据 |
| M_rt    | O    | 32   | M阶段`rt`寄存器数据 | 
- FU相当于MUX的**选择信号**而不是**使能信号端**，**能否进行转发是SU模块进行判断的**；
- 所以我们只需要判断A模型也就是该指令要写入的addr与需求者的addr是否一致就可以了；
- 我们进行选择的时候，尽可能要选择路径短的，也就是M级里的数据优先级大于W级里的；
- （但是现在我又觉得这个FU单元如果直接在顶层模块中使用好像也不是不行^ ^;）
- 如果是在主电路里转发，我们只需要添加几个多路选择器即可：

| 阶段  | 描述                                                                          | 转发数据 |
| ----- | ----------------------------------------------------------------------------- | -------- |
| D阶段 | D阶段`rs`和`rt`都需要转发，其中W级已经在GRF内部转发，需要E（最优）和M级即可。 |          |
| E阶段 | 需要M阶段和W阶段的数据转发`rt`和`rs`，其中M阶段最优                           | PC8      |
| M阶段 | 需要W阶段的数据转发`rt`即可                                                   | PC8、ALUout   |
| W阶段 | 不需要转发                                                                    | W_RegData         |

### SU
---
SU单元是判断是否停止的单元，也就是AT模型进行判断，先判断addr，在判断T，那么我们这个单元的端口都比较简单，如下：

| 端口    | 方向 | 位宽 | 描述      |
| ------- | ---- | ---- | --------- |
| D_Instr | I    | 32   | D阶段指令 |
| E_Instr | I    | 32   | E阶段指令 |
| F_Instr | I    | 32   | F阶段指令 |
| stall   | O    | 1    | 暂停信号  |
- 由于我们都是把信号阻塞在D阶段，那么我们就只需要计算出D阶段的Tuse，并将其与各个阶段的Tnew比较；

### F_IFU
---
IFU没什么好搭的，和P4差不多，这里我们直接导入P4的表格；

| 端口  | 方向 | 位宽 | 描述             |
| ----- | ---- | ---- | ---------------- |
| clk   | I    | 1    | 时钟周期         |
| reset | I    | 1    | 同步复位信号     |
| NPC   | I    | 32   | 下一周期指令地址 |
| Instr | O    | 32   | 输出的指令       |
| PC    | O    | 32   | 这一周期的指令地址                 |

### D阶段
---
#### D_REG
---
这个是D级流水级，也就是存F阶段需要传入D阶段的值。

| 端口    | 方向 | 位宽 | 描述                        |
| ------- | ---- | ---- | --------------------------- |
| clk     | I    | 1    | 时钟信号                    |
| reset   | I    | 1    | 复位信号，优先级最高        |
| WE    | I    | 1    | 可写入信号，优先级次于`reset` |
| F_PC    | I    | 32   | F阶段要传入D阶段的PC        |
| F_Instr | I    | 32   | F阶段要传入D阶段的指令      |
| D_Instr | O    | 32   | D阶段指令                   |
| D_PC    | O    | 32   | D阶段PC                     |
#### D_GRF
---
我们仍然是直接导入P4代码；

| 端口  | 方向 | 位宽 | 描述                        |
| ----- | ---- | ---- | --------------------------- |
| clk   | I    | 1    | 时钟信号                    |
| reset | I    | 1    | 同步复位信号                |
| WE    | I    | 1    | 写使能信号                  |
| A1    | I    | 5    | 第一个reg地址               |
| A2    | I    | 5    | 第二个reg地址               |
| A3    | I    | 5    | 可能需要写入的第三个reg地址 |
| WD    | I    | 32   | 写入寄存器的数据            |
| PC    | I    | 32   | 评测机测试使用                            |
| RD1   | O    | 32   | 读出第一个reg的数据         |
| RD2   | O    | 32   | 读出第二个reg的数据         |
但是，需要注意的是，
- 我们需要在GRF加一个内部转发电路，也就是我们要读的数据是写的地址的时候，我们直接读入写入的数据；
#### D_EXT
---
照搬，但是需要注意的是，我进行了一小点改进，也就是把`lui`在这个地方进行了。

| 端口      | 方向 | 位宽 | 描述                   |
| --------- | ---- | ---- | ---------------------- |
| imm       | I    | 16   | 16位立即数             |
| opEXT     | I    | 2    | 扩展信号               |
| EXTout       | O    | 32   | 扩展后的结果                       |

#### D_NPC
---
这个器件和P4差别非常大；

| 端口   | 方向 | 位宽 | 描述                     |
| ------ | ---- | ---- | ------------------------ |
| F_PC   | I    | 32   | 本周期F阶段的指令地址    |
| D_PC   | I    | 32   | 本周期D阶段的指令地址    | 
| Branch | I    | 32   | 跳转分支值符号扩展后     |
| Index  | I    | 26   | 跳转的target值           |
| rs     | I    | 32   | 跳转寄存器内的pc值       |
| opNPC  | I    | 3    | 选择执行指令地址计算方案 |
| Bflag  | I    | 1    | 是否能够跳转分支         |
| stall  | I    | 1    | 暂停信号                 |
| NPC    | O    | 32   | 下一周期的指令地址       |
- `zero`信号转换为`Bflag；
- 暂停信号优先级在这里最高，所以如果暂停那么PC应该停在F_PC；
- 如果正常进行，应该是F_PC+4；
- 如果进行跳转，为了实现延迟槽，我们需要计算的PC是D_PC；
#### D_CMP
---
这个器件主要执行B类型跳转指令

| 端口     | 方向 | 位宽 | 描述       |
| -------- | ---- | ---- | ---------- |
| rs       | I    | 32   | rs寄存器值 |
| rt       | I    | 32   | rt寄存器值 |
| opBranch | I    | 3    | B指令类型  |
| Bflag    | O    | 1    | B类型是否能够成功跳转           |
- 在P5只用到一个指令，但是为了P6着想，还是将位宽放大一些。

### E阶段
---
#### E_REG
---
E级流水级REG主要传入的数据是：

| 端口    | 方向 | 位宽 | 描述                       |
| ------- | ---- | ---- | -------------------------- |
| clk     | I    | 1    | 时钟信号                   |
| reset   | I    | 1    | 复位信号，优先级最高       |
| clr   | I    | 1    | 清除信号，主要用于阻塞使用 |
| D_PC    | I    | 32   | D阶段要传入E阶段的PC       |
| D_Instr | I    | 32   | D阶段要传入E阶段的指令     |
| D_rs    | I    | 32   | D阶段的rs寄存器值          |
| D_rt    | I    | 32   | D阶段的rt寄存器值          |
| D_Imm   | I    | 32   | D阶段的立即数值            |
| E_Instr | O    | 32   | E阶段指令                  |
| E_PC    | O    | 32   | E阶段PC                    |
| E_rs    | O    | 32   | E阶段的rs寄存器值          |
| E_rt    | O    | 32   | E阶段的rt寄存器值          |
| E_Imm   | O    | 32   | E阶段的立即数值            |

#### E_ALU
---
ALU我们直接套用P4的ALU：

| 端口      | 方向 | 位宽 | 描述                   |
| --------- | ---- | ---- | ---------------------- |
| SrcA      | I    | 32   | 第一个运算数           |
| SrcB      | I    | 32   | 第二个运算数           |
| opALU    | I    | 4    | 运算类型               |
| ALUresult | O    | 32   | 运算结果               |
- 注意没有了zero判断因子；

### M阶段
---
#### M_REG
---
M级流水级也是传递一些数据：

| 端口        | 方向 | 位宽 | 描述                   |
| ----------- | ---- | ---- | ---------------------- |
| clk         | I    | 1    | 时钟信号               |
| reset       | I    | 1    | 复位信号，优先级最高   |
| E_PC        | I    | 32   | E阶段要传入M阶段的PC   |
| E_Instr     | I    | 32   | E阶段要传入M阶段的指令 |
| E_ALUresult | I    | 32   | E阶段计算的ALU值       |
| E_rt        | I    | 32   | E阶段的rt寄存器值      |
| M_Instr     | O    | 32   | M阶段指令              |
| M_PC        | O    | 32   | M阶段PC                |
| M_ALUresult | O    | 32   | M阶段储存的ALU的结果      |
| M_rt        | O    | 32   | M阶段传入的`rt`寄存器的值      |
- 注意从M级开始没有了`clr`和`WE`等信号；

#### M_DM
---
这里我们直接套用P4的DM，但是需要注意的是要有字节存取和半字节存取

| 端口      | 方向 | 位宽 | 描述                            |
| --------- | ---- | ---- | ------------------------------- |
| clk       | I    | 1    | 时钟信号                        |
| reset     | I    | 1    | 通步复位信号                    |
| WE        | I    | 1    | 是否写信号                      |
| WD        | I    | 32   | 写入的数据                      |
| addr      | I    | 32   | 输入的地址（需要转换为RAM地址） |
| PC        | I    | 32   | 测试用                          |
| LoadType  | I    | 3    | 加载数据的类型                  |
| StoreType | I    | 2    | 存储数据的类型                  |
| RD    | O    | 32   | 读出的数据                      |
- 注意`display`的时候是字对齐的，
- 注意存储和加载的类型，注意加载是符号扩展

### W_REG
---
W级流水级也是储存一些数据：

| 端口        | 方向 | 位宽 | 描述                   |
| ----------- | ---- | ---- | ---------------------- |
| clk         | I    | 1    | 时钟信号               |
| reset       | I    | 1    | 复位信号，优先级最高   |
| M_PC        | I    | 32   | M阶段要传入W阶段的PC   |
| M_Instr     | I    | 32   | M阶段要传入W阶段的指令 |
| M_ALUresult | I    | 32   | M阶段的ALU值           |
| M_DMout        | I    | 32   | M阶段读取的DM值        |
| W_Instr     | O    | 32   | W阶段指令              |
| W_PC        | O    | 32   | W阶段PC                |
| W_ALUresult | O    | 32   | W阶段的ALU             |
| W_DMout        | O    | 32   | W阶段传入的DM读取值    | 

### 实例化
---
下面就是最难最抽象最复杂最恶心的实例化阶段力，我们一个阶段一个阶段来，就可以了。

## 思考题
---
**1. 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。**

	我们提前分支判断，是在D阶段直接进行了跳转指令判断，但是可能会因为判断需要用的寄存器在D阶段时还没有产生，我们要阻塞一周期，这和我们在E阶段判断跳转的效率是一样的。
	例如指令：`add $t1, $t0, $t0` `beq $t1, $0, label`

**2. 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？**

	因为在jal进行跳转判断的时候，F阶段新的指令（PC+4）已经取出来了，如果我们不允许延迟槽，这条指令就会消失，那么跳转之后写回的就是PC+4；由于我们允许延迟槽，所以这条指令继续进行，不消除，那么我们写回的时候就需要写回PC+8，因为PC+4这条指令已经被执行了；
	这样设计的好处就是可以节约很多效率，因为流水线就是为了性能而生的，这样能大大提高性能；

**3. 我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？**

	我们如果来源于功能部件，那么就可能本来是之前的功能部件的正确的值，由于竞争冒险，又计算出了新的值，我们不知道我们这个数据取到了哪一个值，更不知道哪一个值是正确的，会出现很多意想不到的错误；

**4. 我们为什么要使用 GPR 内部转发？该如何实现？**

	因为有可能GPR中读出的寄存器是即将写入的值，那么我们直接读出要写入的值就可以了。内部转发就直接省略了D阶段需要W阶段传入数据的这一过程，解决了这一转发路径，并且这样转发十分方便；否则我们需要将W写入和读出数据分成两个不同阶段进行。实现就只需要在GPR中加一个组合逻辑，即：
``` verilog
assign RD1 = (A1 == 5'd0) ? 32'h0000_0000 : 
					  (A1 == A3) ? WD : Register[A1];
```

**5. 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？**

	数据的需求者来源于D阶段CMP的rs，rt; NPC的rs; E阶段ALU的rs，rt; M阶段DM的rt;
	数据的供给者可能是E阶段的PC+8（jal指令写回时）; M阶段的ALUout(E阶段传入的); W阶段的WD; 
	在我设计的CPU中，D阶段有rs和rt分别有两条，其中W阶段已经在GPR内部转发实现了，一条路径来自于M阶段的ALUout，另一条来源于E阶段的PC+8; E阶段的rs和rt也有两条，一条来自于M阶段的ALUout，一条来自于W阶段的WD; M阶段的rt只有一条，来自于W阶段的WD;

**6. 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置.**

	课上的指令主要是三类，计算+跳转+访存。
	根据我之前对指令的分类，如果只是普通的计算跳转访存直接在CU写法中归类就可以了（也就是P6的写法），将他们归为特定的类别，然后共用公有信号就可以了。但是我们的课上肯定不会是这样的。我们课上考到的一定是有条件的，条件访存，条件写，条件跳转等等；
	计算类：
	如果是普通计算类，只需要改一下ALUop给他加一个op信号，然后在CU给他译码为TypeR或者TypeI（倒不如直接单独加一个控制信号，只是或一起，而不是一起考虑，这个时候Tuse和Tnew计算需要单独考虑，有些复杂），再在ALU中实现他的计算直接秒;（修改信号：opALU，可能修改opEXT，将他归类到R或者I）
	他往往是条件写，也就是我只有在某个条件下才写入，算出的数值小于某个数就不能写，那么这个时候就需要在ALU中添加一个flag信号，然后flag传下去指示是否写入。这个时候需要注意的是，我们的寄存器能否写入要影响转发和阻塞。那么我们这个时候该怎样考虑呢？我觉得就是要在转发时，数据端口加一个是否ALU允许的信号，如果允许就是即将写入的数据，如果不允许我们就是题中的数据。也就是我们不动转发的位置，我们只动转发的数据。即：RegData。如果可以的话我们直接在ALU中修改ALUout就可以了。
	但是还有一种可能就是他如果计算不成功，就不允许写入了，那么这个时候，我们不管他就行了，只需要将flag传下去，并且指示GRF的WE就可以了（在每个转发电路里都加一个这样的flag，并且这个flag只有在是这个指令并且计算结果满足的情况下才会生效）。或者将他的要写入的RegAddr转化为0号寄存器（这个在主电路里加一个assign语句根据flag和指令类型判断就可以了）。
	跳转类：
	这个如果是普通的，直接在CMP里写就可以了。
	对于复杂一些的，可能即要在CMP里比较，还要存PC8。这样我觉得还是弄成TypeB方便计算，并且单独加一个信号写入信号。
	但是有的时候是跳转才写入，不跳转就不写入了。这样还需要将传出来的Bflag和他的控制信号结合，将Bflag流下去，并且根据解析他的指令类型判断是否写入的flag信号，同alu；
	访存类：
	如果是普通的，直接写DM。归类为TypeS或者TypeR，并且译码出自己的ReadType或者WriteType。
	复杂的如果只牵扯到写入DM，那么在DM自己实现就可以了；如果牵扯到条件写寄存器等，和跳转类计算类实现方式一样。将Flag传下去，或者能直接改DMout就改DMout。如果是能否写入相关的就流下去flag。


**7. 简要描述你的译码器架构，并思考该架构的优势以及不足。**

	我的译码器架构是分支译码，但是我用的是一个总的CU，在每个分支传入他自己的指令译码出他想要的数据就可以，在我的CU阶段我写有所有指令需要在哪个阶段译码，哪个阶段提取。这样写的话，并且流水级寄存器也少了许多传输信号，非常利于读懂代码; 缺点就是如果有新增指令，那么几乎每个实例化都要修改要传入的信号，而且这样写会消耗许多门电路（现在还不考虑性能）, 也就是不太利于课上实现, 要实现的话也要把课上指令归纳到课下的分类中，其次后续各个阶段的复杂度也大大提升。

**8. [P5 选做] 请详细描述你的测试方案及测试数据构造策略。**

	我觉得还是主要考虑到了跳转指令和延迟槽，因为跳转指令默认就需要进行阻塞，否则绝对是错误的，所以仅仅测一测跳转指令就ok了。
	其次，我的数据和P4差不多，只不过再每个跳转指令时，我都选择延迟槽是否实现。因为P4的延迟槽没有实现，所以按照没有延迟槽的代码逻辑，和加了延迟槽的逻辑都跑一遍，最后对比一下在MARS中运行的结果就可以了。

``` MIPS
lui $t1, 0xffff
ori $t1, 0xfffe
ori $t0, 2
lui $ra, 0xffff
ori $ra, 0xffff
jal function
add $t4, $t1, $t1
sw $t4, 0($0)
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_1_begin:
beq $s0, $s1, for_1_end
nop
	add $s5, $s0, $s5
add $s0, $s0, $s2
nop
jal for_1_begin
## nop
for_1_end:
ori $s0, 0
ori $s1, 32
ori $s2, 1
for_2_begin:
beq $s0, $s1, for_2_end
nop
	add $s6, $s0, $s6
	jr $ra
add $s0, $s0, $s2
nop
jal for_2_begin
nop
for_2_end:
beq $s6, $s5, end
beq $s0, $s6, end
beq $s6, $s2, end
beq $s0, $s2, end
beq $0, $7, end
function:
lui $t2, 0xffff
ori $t2, 0xfffe
ori $t3, 2
lui $t4, 0xffff
ori $t4, 0xffff
beq $t1, $t2, jump
## nop 这个nop不加会出错误
lui $ra, 0
ori $ra, 0
jump:
sub $t4, $t4, $t1
beq $t4, $t1, function
## nop 这个nop不加还会有错，可能是延迟槽出现了跳转指令
jr $ra
end:
##nop  这个nop不加也会出错
```

## 课上考试
---
1. 考前准备
	- 课上千万别急，先稳住心态，深呼吸，看好电路图；
	- 先用ISE创建几个工程项目，并且创建一个test文件；
	- 考试开始后，先阅读考试说明，查看指令集，下载zip文件，下载每一个指令的class并且导入mars；
	- 将zip解压缩之后修改SU中的阻塞，再提交到三个指令中，看看有没有课下错误，有课下错误先de课下错误；
	- 然后先把错误代码写到纸上，随后开始分析正是写题。
2. 计算类（R or I）
	1. 首先，先在宏定义中加上指令译码，一定不要进行归类（如果有条件写的话），并且在ALUout中加入操作信号；
	2. 然后，在CU中进行改变，output加一个这样的指令名称，并且选择他需要的信号；
	3. 如果没有条件写，那可以直接秒了；
3. 跳转类（B + jl）
	1. 首先，宏定义加上指令译码，加一个opCMP信号，然后在CU中进行改变，往往opEXT可以归类，opBranch也可以；
	2. 其次，注意他可能有写回PC8的指令，那么我们可以加一个check信号，和Bflag信号值一样，并且通过流水传下去（需要在草图上表示清楚）；
	3. 最后，改变CU的Reg类操作，WE一定是1，但是写入的可能是0号寄存器（也就是不写不转发），DataSel是PC8（如果写的话）；
4. 访存类（L or S + condition）
	1. 首先，宏定义加上指令译码，看看访存的类型，然后在CU中改变opEXT，ALUsrcB，loadtype或storetype，还有DMWE；
	2. 其次，如果是条件加载，也就是可能加载也可能不加载，那么我们在判断SU的时候，要把这条指令译码出来，并且把如果可能冲突就阻塞，直到判断出真的写不写之后，也就是说在E阶段需要加一个保守的阻塞信号；
	3. 最后，流传下去的方法和跳转类一样；
5. 考试心态
	1. 心态一定要平稳，读三遍题再写，千万别把题目看错；
	2. 加油，你一定可以成功的！加油！