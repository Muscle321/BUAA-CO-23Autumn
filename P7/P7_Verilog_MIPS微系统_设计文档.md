# MIPS微系统
---
由于本人十分菜，几乎不了解MIPS微系统的各个结构及各个部件的作用，所以我打算进行一下几个步奏来学习这个project：
1. MIPS微系统概述，先了解MIPS微系统的具体结构是什么，掌握基本的理论知识；
2. 分析清楚各个部件之间的接口关系，能够画图画出来各个结构；
3. 对每个部件独立的进行建模完善；考虑各种可能出现的异常情况；
4. 最后搭建最后的MIPS微系统；
5. 思考题和测试；

# 概述
---
微系统不同于流水线CPU的地方很多，他比流水线CPU多了很多部件，也叫做外设吧，我们也多了不少部件，具体有如下这些方面吧：

| 部件        | 解释                                                                   | 实现                                                         |
| ----------- | ---------------------------------------------------------------------- | ------------------------------------------------------------ |
| 计时器      | 在固定地址找几个字节，然后使其有计时功能，时不时有个中断的             | 官方实现                                                     |
| 系统桥      | 相当于CPU访问地址的一个接口，通过系统桥判断访问DM还是计时器还是中断    | 一个组合逻辑电路，判断地址流向                               |
| 协处理器CP0 | 帮助CPU解决中断异常的发生，和HILO部件类似，多了几个寄存器存储各种东西  | 时序逻辑，但是和CPU联系比较密切，可以划分到CPU内部的一个部件 |
| 中断发生器  | 类似于计时器的一个东西，但是比计时器要简单的多，就是时不时传来是否中断 | 就一个地址实现                                               |
| 单周期CPU   | 我们要把流水线CPU封装为单周期CPU，使其的IO口能和其他相连               | 就把流水线CPU一些数据传出来就行                              | 
![[Pasted image 20231201173746.png]]
我们实际上多的部件只有CP0，连个Timer计时器，和一个系统桥。
对于每一个部件我们一个一个分析

# Timer计时器
---
说实话，我对计时器的理解还是不够深，我在网上找了一些相关资料还是没怎么弄明白它存在的具体意义和作用。
我只知道这个东西就是多了三个字的地址，然后会时不时传出一些中断信号。
还好官方给实现了。
我们只需要在主电路里进行两个实例化就可以了，只是对于是否写入这两个Timer需要在系统桥中做判断。

| 端口  | 方向 | 位宽   | 解释     |
| ----- | ---- | ------ | -------- |
| clk   | I    | 1      | 时钟信号 |
| reset | I    | 1      | 复位信号 |
| Addr  | I    | [31:2] | 写入地址 |
| WE    | I    | 1      | 使写能   |
| Din   | I    | 32     | 输入数据 |
| Dout  | O    | 32     | 读出数据 |
| IRQ   | O    | 1      | 中断信号 | 
- 这个中断信号本质上是TC时不时传入的外部中断，并非内部中断；
- 对于TC可能出现的取值存值异常内部异常，我们选择在CPU内部判断。
# 系统桥
---
我理解的系统桥的作用，就是连接CPU和地址的一座桥，我们把地址对应的映射写出来：

| 条目             | 地址范围                 | 解释 |
| ---------------- | ------------------------ | ---- |
| DM               | 0x0000_0000~0x0000_2FFF |      |
| IM               | 0x0000_3000~0x0000_6FFF |      |
| PC初值           | 0x0000_3000              |      |
| 异常处理程序入口 | 0x0000_4180              |      |
| 计时器0          | 0x0000_7F00~0x0000_7F0B  |      |
| 计时器1          | 0x0000_7F10~0x0000_7F1B  |      |
| 中断发生器       | 0x0000_7F20~0x0000_7F23  |      |
而系统桥就是作为一个中间，传入我们CPU要的地址，然后传回去数据就可以了。

| 端口              | 方向 | 位宽 | 解释                     |
| ----------------- | ---- | ---- | ------------------------ |
| pre_m_data_addr   | I    | 32   | CPU计算出的地址          |
| pre_m_data_wdata  | I    | 32   | CPU传入需要写的数据      |
| pre_m_data_byteen | I    | 4    | CPU传入写数据的格式      |
| pre_m_inst_addr   | I    | 32   | 该指令的地址             |
| pre_m_data_rdata  | I    | 32   | DM或中断处理器传入的数据 |
| TC0_Dout          | I    | 32   | TC0传入的数据            |
| TC1_Dout          | I    | 32   | TC1传入的数据            |
| m_data_addr       | O    | 32   | 通过桥计算出的地址       |
| m_data_wdata      | O    | 32   | 通过桥之后需要写的数据   |
| m_data_byteen     | O    | 4    | 通过桥后传入写数据的格式 |
| m_inst_addr       | O    | 32   | 通过桥该指令的地址       |
| m_data_rdata      | O    | 32   | 桥传入CPU的数据          |
| TC0_WE            | O    | 1    | TC0是否写入信号          |
| TC0_Din           | O    | 32   | 传入TC0的写入数据        |
| TC0_Addr          | O    | 32   | 传入TC0的写入地址        |
| TC1_WE            | O    | 1    | TC1是否写入信号          |
| TC1_Din           | O    | 32   | 传入TC1的写入数据        |
| TC1_Addr          | O    | 32   | 传入TC1的写入地址        |
| m_int_addr        | O    | 32   | 传入中断发生器的地址     |
| m_int_byteen      | O    | 4    | 传入中断发生器的写入类型                         |
- 这里有个问题，对于`sh sb`类型指令不能写入TC，会产生异常，这个异常判断目前不确定是否要在桥中做判断。
- 这个异常本质还是内部异常，不属于外部异常，而桥属于外设类的，所以我选择把所有`store`和`load`类型的指令在CPU中进行判断。
- 我觉得系统桥就是一个大型的多路选择器，实际上就是个组合电路，没什么难的。
# CP0协处理器
---
这个部件我觉得是在CPU内部的，CPU是中央处理器，CP0是协处理器也就是协助CPU处理指令的。我们知道CPU有许多指令在异常的时候无法执行，或者会出现错误，我们的软件很有可能使CPU出现错误无法执行的程序，那么这个时候就需要CP0来解决这个问题了。

那么CP0需要实现的就一些指令`eret, syscall, mfc0, mtc0`，和各种可能出现的异常，包括内部异常检测，外部异常中断，并且最后使CPU跳转到异常指令执行异常指令。

我们最好把CP0放在M阶段，因为W阶段不会有异常，那么之前的异常都可以通过流水传到M阶段，这样进行异常处理更加方便。

| 端口      | 方向 | 位数 | 解释             |
| --------- | ---- | ---- | ---------------- |
| clk       | I    | 1    | 时钟信号         |
| reset     | I    | 1    | 复位信号         |
| en        | I    | 1    | 写使能信号       |
| CP0Add    | I    | 5    | 寄存器地址       |
| CP0In     | I    | 32   | CP0写入数据      |
| CP0Out    | O    | 32   | CP0读出数据      |
| VPC       | I    | 32   | 受害PC           |
| BDIn      | I    | 1    | 是否为延迟槽指令 |
| ExcCodeIn | I    | 5    | 记录异常类型     |
| HWInt     | I    | 6    | 输入中断信号     |
| EXLClr    | I    | 1    | 用来复位EXL(当M阶段为ERET时复位)      |
| EPCOut    | O    | 32   | EPC的值          |
| Req       | O    | 1    | 进入处理程序请求 |

CP0中我们还需要实现三个寄存器`SR, Cause, EPC`

| 寄存器 | 功能域  | 位域    | 解释 |
| ------ | ------- | ------- | ---- |
| SR     | IM      | [15:10]  | 分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，==只能通过 `mtc0` 这个指令修改==，通过修改这个功能域，我们可以屏蔽一些中断。     |
| SR     | EXL     | 1       | 任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。     |
| SR     | IE      | 0       | 全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。     |
| Cause  | BD      | 31      | 当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。     |
| Cause  | IP      | [15:10] | 为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。     |
| Cause  | ExcCode | 6:2     | 异常编码，记录当前发生的是什么异常。     |
| EPC    |         | [31:0]  | 记录异常返回的PC     |

# 新增指令
---
- 我觉得先写新增指令比较合适，比较方便实现；
- 新增了`mfc0`，`mtc0`，`eret`，`syscall`；

| 指令    | 解释                                                       | 
| ------- | ---------------------------------------------------------- |
| mfc0    | 读CP0寄存器，写入一个寄存器，所以Tnew为2，并且可能需要转发 |
| mtc0    | 写CP0寄存器，需要考虑和eret的阻塞问题                      |
| eret    | 异常返回，需要考虑阻塞问题，也就是mtc0可能写EPC            |
| syscall | 系统异常调用                                               |
- 注意此时需要在每个流水寄存器加一个Req信号；
- 然后再把CP0在CPU中进行实例化；
- 乘除单元进行判断；
- D_NPC单元需要修改，多了两个路径，一条是eret，一条是异常的时候进入特定PC；
# 异常判断
---

| ExcCode | 助记符  | 描述                   |
| ------- | ------- | ---------------------- |
| 0       | Int     | 外部中断               |
| 4       | AdEL    | 取数（M阶段）或者取指（F阶段）时地址错误 |
| 5       | AdES    | 存数时地址错误（M阶段）         |
| 8       | Syscall | 系统调用（D阶段）               |
| 10      | RI      | 不认识的指令码（D阶段）         |
| 12      | Ov      | 整数算术指令溢出（E传到M阶段判断）       |

# 思考题
---
**1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的?**

		键盘是常用的输入设备，它是由一组开关矩阵组成，包括数字键、字母键、符号键、功能键及控制键等。每一个按键在计算机中都有它的惟一代码。当按下某个键时，键盘接口将该键的二进制代码送入计算机处理器中，并将按键字符显示在显示器上。当快速大量输入字符，主机来不及处理时，先将这些字符的代码送往内存的键盘缓冲区，然后再从该缓冲区中取出进行分析处理。键盘接口电路多采用单片微处理器，由它控制整个键盘的工作，如上电时对键盘的自检、键盘扫描、按键代码的产生、发送及与主机的通讯等。
		鼠标是输入设备，鼠标通过南桥将位置位移及点击信息传送给cpu，cpu计算后再将结果等一堆信息传送给显卡，显卡生成图像通过dp、dvi、hdmi等接口输出到显示器。
		总的来说：鼠标和键盘产生中断信号，进入中断处理区的对应位置，将输入信号从鼠标和键盘中读入寄存器。

**2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）**

		可以，但若用户操作不当可能会对存储有 CPU 初始数据和命令的地址区域进行读写，或将连续的地址空间分割，增加了数据丢失和指令处理混乱的风险，并大大增加了硬件设计的难度。

**3、为何与外设通信需要 Bridge？**

		Bridge实际上是一个大型的多路选择器，是一个组合电路，顾名思义，就是连接CPU和外设的一座桥梁。

**4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。**

		模式0：
		当计数器倒计数为 0 后，计数器停止计数，此时控制寄存器中的使能 Enable 自动变为 0。当使能 Enable 被设置为 1 后，初值寄存器值再次被加载至计数器，计数器重新启动倒计数。通常用于产生定时中断。
		模式1：
		当计数器倒计数为 0 后，初值寄存器值被自动加载至计数器，计数器继续倒计数。常用于产生周期性脉冲。

**5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？**

		会丢失上一级指令的延迟槽信息、可能记录的错误信息；这样处理也与“单周期的封装”的目的相违背，因为可能会凭空生成 nop 指令。

**6、为什么 jalr 指令为什么不能写成 jalr $31, $31？**

		如果这样的话就会造成同时读写31号寄存器，若读写同一寄存器，则当前pc的值加4会被再次写入该寄存器，若产生异常，则当前CPU结构无法消除其已经改变的值，造成错误的指令行为。

# 测试数据
```
# 程序首先从这里运行
.text
    # 只允许外部中断
    ori $t0, $0, 0x1001
    mtc0 $t0, $12

    # 算术溢出
    lui $t0, 0x7fff
    lui $t1, 0x7fff
    add $t2, $t0, $t1

end:
    beq $0, $0, end
    nop

.ktext 0x4180
_entry:
    # 保存上下文
    j _save_context
    nop

_main_handler:
    # 取出 ExcCode
    mfc0 $k0, $13
    ori $k1, $0, 0x7c
    and $k0, $k0, $k1

    # 如果是中断，直接恢复上下文
    beq $k0, $0, _restore_context
    nop

    # 将 EPC + 4，即处理异常的方法就是跳过当前指令
    mfc0 $k0, $14
    addu $k0, $k0, 4
    mtc0 $k0, $14
    j _restore_context
    nop

_exception_return:
    eret

_save_context:
    ori $k0, $0, 0x1000     # 在栈上找一块空间保存现场
    addiu $k0, $k0, -256
    sw $sp, 116($k0)        # 最先保存栈指针
    move $sp, $k0

    # 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO
    sw $1, 4($sp)
    sw $2, 8($sp)
    # ......
    sw $31, 124($sp)
    mfhi $k0
    mflo $k1
    sw $k0, 128($sp)
    sw $k1, 132($sp)

    j _main_handler
    nop

_restore_context:
    # 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO
    lw $1, 4($sp)
    lw $2, 8($sp)
    # ......
    lw $31, 124($sp)
    lw $k0, 128($sp)
    lw $k1, 132($sp)
    mthi $k0
    mtlo $k1

    # 最后恢复栈指针
    lw $sp, 116($sp)

    j _exception_return
    nop
```