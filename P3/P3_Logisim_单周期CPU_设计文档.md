# CPU
---
- 首先，在我看来，CPU是一种微体系结构，是将逻辑和体系结构层次的抽象连接在一起的。逻辑层面就是我们之前所搭建的各种组合逻辑、时序逻辑等电路，而体系结构描述了程序员观点的计算机抽象。也就是说，CPU就是连接底层逻辑和程序员需求之间的一座桥梁，程序员可以根据自己想要实现的需求，设计不同的逻辑结构，从而实现自己想要的目标。
- 那么，我们在了解CPU的意义之后，就需要设计CPU，我们需要将CPU模块化。根据黑书所描述的，我们需要遵循3Y原则，即层次化(hierarchy)、模块化(modularity)、规整化(regularity)。
	1. 层次化，需要我们把CPU分为若干个模块，进一步划分每个模块的功能即可；
	2. 模块化，需要我们对于每个单一模块都规定好他的功能和接口，以便于他们之间能够容易链接，而不会产生意想不到辅作用；
	3. 规整化，在模块之间寻求一致，通用模块可以用很多次，以减少不同模块的数量（这就要求我们不仅要将其模块化，还要有水平的模块化，这个模块不能过多显得冗杂，也不能过少导致主电路过于复杂）。
	（参考资料：黑书P3）
- 接着，我们在模块化之后，需要对每个模块分别进行测试和改进，不断完善每个模块的功能，同时也避免最后连在一起的时候出现个小差错导致debug半天；
- 然后，就是把CPU搭建起来的过程了，在这里我们就需要了解单周期CPU处理指令的过程及先后顺序，然后将他们通过组合逻辑（共用一个clk和异步复位信号）搭建起来;
- 最后，就是进行CPU功能的测试了，在测试CPU功能的过程，一定要尽可能保证数据的完备，各个方面都要涉及，尤其是介于边界的数据，可以参考[实验教程_P3_测试CPU](http://cscore.buaa.edu.cn/tutorial/P3/P3-4/)

## CPU意义
---
> 1. **指令控制**。完成取指令、分析指令和执行指令的操作，即程序的顺序控制
> 2. **操作控制**。一条至零点功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件（ALU），从而控制这些部件按指令的要求进行动作。
> 3. **时间控制**。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
> 4. **数据加工**。对数据进行算术和逻辑运算。
> 5. **中断处理**。对计算机运行过程中出现的异常情况和特殊请求进行处理
（参考文献：[ CPU的功能和基本结构](https://blog.csdn.net/Bella_Notte/article/details/132612234)）

也就是说CPU的根本目的就是——**控制指令执行**
（在P3之中，我们只需要用到前四个功能，没有对中断处理有过多的要求）
我通过查阅资料，了解了单周期CPU，即在一个时钟周期中完成取指令、取数、运算的过程，这几个周期合并为一个指令周期。

## CPU模块化
---
在了解CPU功能之后，我们可以将CPU所需功能部件简化为两类：
1. 取指令，包括指令地址部件、指令寄存部件、译码部件。
2. 执行指令，包括执行部件（ALU、GRF、DM、EXT等）、控制器部件（Controller即根据指令的特点，通过各个控制信号控制执行部件的运行）。
对于具体需要哪些单元和部件，我们接下来将进行一一讨论。
（在[实验教程_P0_如何设计电路模块](http://cscore.buaa.edu.cn/tutorial/P0/P0-1/)中，我们学习了如何设计电路模块，其中是根据IO口和题目意思判断需要实现的功能，进而搭出电路；而对于CPU模块的搭建，我觉得应该需要先写出实现的功能，再想好需要的控制信号、输出信号等IO口，最后才进行搭电路）

### 地址计算器(NPC)
---
我们要计算下一周期的指令地址，那么我们就需要知道上一周期的指令，并且要考虑到各种计算下周周期指令地址的方式。对于NPC来说，他是程序计数器，那么我们就要想到，我们的指令地址是怎样一个一个被取出来的，一般是按照指令地址顺序执行，但是还会遇到**跳转指令**，并且跳转指令的种类也有很多种，那么我们就需要将其一一列出，并且通过一个控制信号来控制选择哪一种取指令地址的方式。
模块接口：

| 端口 | 方向 | 位宽                 | 描述    | 
| ------ | ---- | -------------------- | --- |
| PC     | I    | 32 | 本周期周期的指令地址    |
| Branch | I    |   32     |  跳转指令的地址   |
| op_PC  | I    | 1 |   选择执行哪一种PC转换 |
| PC'    | O    | 32  |下一周期的指令地址     |
其中op_PC共有四种，可以选择四种不同的计算NPC的方式：

| 控制信号 | 编码 | 描述                           | 指令列举   |
| ---------- | ---- | ------------------------------ | ---------- |
| Normal     | 00    | PC + 4                         | 几乎所有   |
| Branch     | 01    | PC + 4 + ($signed(branch))<<2    | beq、bne等 |
| J          | 10    | {PC[31:28], branch[25:0], 0,0} | j、jal     |
| JR         | 11    | branch                         | jalr、jr   |
在本次实验中，我们仅用到了前两种转换类型。故op是1即可

### 取指令单元(IFU)
---
取指令部件，顾名思义，就是取出当前PC地址对应的指令，因为我们的CPU的根本目的是**控制指令执行**，那么我们所有的部件都离不开指令这一要素。
我们要把指令存在ROM地址当中，而ROM地址与PC地址又有所不同。对于输入的PC范围是0x00003000~0x00006FFF，而ROM中只能从0开始读取，那么我们就需要通过一个电路将PC地址转化为ROM的地址，并且储存起来，最后再转化为实际的PC地址进行输出。

功能定义：

| 序号 | 功能名称      | 功能描述                                                                       |
| ---- | ------------- | ------------------------------------------------------------------------------ |
| 1    | 指令存储器IM  | 能够输出该周期PC对应的指令                         |
| 2    | 程序计数器PC  | 输出PC指向当前指令，输入下一周期的PC                                                                               |
#### IM
---
模块接口：

| 端口  | 方向 | 位宽                       |  描述      |
| ----- | ---- | -------------------------- | --- |
| clk   | I    | 1                       |  时钟   |
| Reset | I    | 1              |    异步复位信号  |
| PC   | I    | 32             |  该周期指令地址   |
| Instr | O    |32 |    这一时钟周期需要执行的指令  |
#### IFU
---
模块接口：

| 端口  | 方向 | 位宽 | 描述                       |
| ----- | ---- | ---- | -------------------------- |
| clk   | I    | 1    | 时钟                       |
| Reset | I    | 1    | 异步复位信号               |
| PC'   | I    | 32   | 下周期指令地址             |
| Instr | O    | 32   | 这一时钟周期需要执行的指令 |
| PC    | O    | 32   | 本周期指令地址             |
### 执行部件
---
执行部件，也就是执行指令的部件。那么我们就要思考，我们的指令需要如何执行呢？
- 首先，每个指令的操作需要基于操作数，那么只有快速访问操作数指令才能快速执行，于是，我么可以通过访问32个寄存器来找到操作所需要操作的数据。于是我们就需要一个寄存器文件GRF。
- 其次，我们要想到执行操作需要有哪些类型的操作呢？一定有的就是基础算术逻辑运算，例如加减乘除等等，这就需要一个算术逻辑运算单元ALU；有的操作还需要扩展，也就是EXT。
- 最后，对于数组类型数据，我们都是将数据储存在连续的地址当中，于是我们就需要一个数据储存器来实现我们的数据load和store。

#### 寄存器文件(GRF)
---
模块接口：

| 端口      | 方向 | 位宽 | 描述                |
| --------- | ---- | ---- | ------------------- |
| clk       | I    | 1    | 时钟信号            |
| reset     | I    | 1    | 异步复位信号        |
| WE        | I    | 1    | 写使能信号          |
| A1 | I    | 5    | 第一个reg地址       |
| A2 | I    | 5    | 第二个reg地址       |
| A3 | I    | 5    | 可能需要写入的第三个reg地址       |
| WD      | I    | 32   | 写入寄存器的数据    |
| out_reg1  | O    | 32   | 读出第一个reg的数据 |
| out_reg2  | O    | 5    | 读出第二个reg的数据 | 

#### 算术逻辑单元(ALU)
---
ALU运算类型：

| 信号  | 编码 | 描述           |
| ----- | ---- | -------------- |
| add   | 0    | 32位无符号加法 |
| sub   | 1    | 32位无符号减法 |
| or    | 2    | 32位或运算     |
| sll16 | 3    | 移位运算       |
由于指令集中基础的运算类型实在是太多，补充那么多指令也实属折磨，所以目前就仅仅过了课下的指令即可。

模块接口：

| 端口      | 方向 | 位宽 | 描述                   |
| --------- | ---- | ---- | ---------------------- |
| SrcA      | I    | 32   | 第一个运算数           |
| SrcB      | I    | 32   | 第二个运算数           |
| SHF       | I    | 5    | 补充运算数（此次不用） |
| op_ALU    | I    | 3    | 运算类型               |
| ALUResult | O    | 32   | 运算结果               |
| Zero      | O    | 1    | ALUResult是否为0的判断               |

#### 扩展单元(EXT)
---
可以用内置的扩展器，不必单独添加电路

#### 数据储存期(DM)
---
这里我们让他始终读出数据，但是我们读出的数据可以和ALU计算的数据通过一个信号进行一个选择得到我们是输出得到的信号还是输出ALU的计算结果。

模块接口：

| 端口  | 方向 | 位宽 | 描述                            |
| ----- | ---- | ---- | ------------------------------- |
| clk   | I    | 1    | 时钟信号                        |
| reset | I    | 1    | 异步复位信号                    |
| WE    | I    | 1    | 是否写信号                      |
| WD    | I    | 32   | 写入的数据                      |
| addr  | I    | 32   | 输入的地址（需要转换为RAM地址） |
| RD    | O    | 32   | 读出的数据                                |


### 控制器部件(Controller)
---
控制器，就是通过组合逻辑输出控制信号，也就是译码的过程。这一部件是通过翻译指令，之后得到该指令所需要进行的操作，然后输出控制信号控制这些操作的进行。也就是说控制器是取指令部件和执行部件的一座桥梁，取完指令之后通过这座桥梁到达不同的执行部件进行不同操作的执行。
- 首先，我们肯定要知道指令有哪些常见类型，才能够分类型进行操作。有以下三种类型
- 其次，我们可以分析不同的opcode获得不同的操作类型，然后再根据操作类型进行细分得到对应的具体指令。
- 最后，每一个指令可能包括多个操作过程，可能既要进行比较也要读写等等，所以我们需要将其所能用到的操作过程对应的控制信号均置为1。
下面是常见的指令类型：

| 指令类型            | 特点                                     |
| ------------------- | ---------------------------------------- |
| R型(register-type)  | 一般有三个寄存器操作数，且opcode是000000，区别不同R型指令依赖于最后6位funct |
| I型(immediate-type) | 含有16位立即数，有两个寄存器操作数       |
| J型(jump-type)      | 跳转类型，有26位地址操作数               | 
下面是本次课上所需要的控制信号：

| 控制信号类型 | 描述                                            |
| ------------ | ----------------------------------------------- |
| NumRead      | 是否读出DM中的数据                              |
| NumWrite     | 是否向DM中写入数据                              |
| opNPC        | 控制下一条指令地址的计算方式                    |
| opALU[2:0]   | 控制ALU进行的操作                               |
| ALUsrc       | 选择第二个ALU操作数SrcB是立即数还是寄存器中的值 |
| ExtImm       | 立即数扩展选择符号扩展(1)还是零扩展(0) 
| RegWrite     | 是否可以写入寄存器                                                                     |
| RegSel       | 选择写入哪个寄存器，是第二个(值为0)(i型指令)还是第三个(值为1)(R型指令);若不写入，则为x |             |                                                 |
下面是本次课下用到的控制信号与操作的对应关系：

|            |         |         |         |         |         |         |         |         |
| ---------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| opcode     | 00_0000 | 00_0000 | 00_1101 | 10_0011 | 10_1011 | 00_0100 | 00_1111 | 00_0000 |
| funct      | 10_0000 | 10_0010 |         |         |         |         |         | 00_0000 |
| Instr_type | add     | sub     | ori     | lw      | sw      | beq     | lui     | nop     |
| NumRead    | 0       | 0       | 0       | 1       | 0       | 0       | 0       | 0       |
| NumWrite   | 0       | 0       | 0       | 0       | 1       | 0       | 0       | 0       |
| opNPC      | 0       | 0       | 0       | 0       | 0       | 1       | 0       | 0       |
| opALU      | 00      | 01      | 10      | 00      | 00      | 01      | 11      | 00      |
| ALUsrc     | 0       | 0       | 1       | 1       | 1       | 0       | 1       | 0       |
| ExtImm     | 0       | 0       | 0       | 1       | 1       | 1       | 0       | 0        |
| RegWrite   | 1       | 1       | 1       | 1       | 0       | 0       | 1       | 0       |
| RegSel     | 1       | 1       | 0       | 0       | 0       | 0       | 0       | 0       |


## CPU搭建
---
在结束了漫长的模块化之后，我们现在需要搭建CPU。可是看着如此庞大的一个工程，往往不知从何下手，那么我们就按照CPU执行指令的过程，一步一步搭建CPU。
CPU执行指令的过程：
1. 取出指令：通过当前PC取出指令，并且输出当前的PC值，即IFU；
2. 指令译码：再将指令分解成好几部分，分别进入不同的逻辑单元；本次课上只需要分为5部分即可满足R、I型指令；
3. 读取寄存器、立即数：随后就是从GRF中读取寄存器并且根据译码的控制信号控制立即数扩展；
4. 根据控制信号执行操作：根据各种控制信号选择操作数进行ALU或者LS操作；
5. 输出结果得到NPC：输出这一指令的结果，并且得到下一周期的指令NPC。

## CPU数据测试方案
---
`add、sub、ori、lw、sw、beq、lui`这七个指令中`lui、ori`这两个指令是给寄存器赋初值；`add、sub`对寄存器进行运算；`lw、sw`是对DM进行储存和提取；`beq`是跳转指令；我个人认为前边的指令一般来说不会有什么错误，相反，如果前边的指令唯一可能有错误的就是`beq`，容易产生一些出乎意料的bug。所以我写的强测数据主要是检测`beq`指令的正确性。

下面是MIPS指令：
``` MIPS
lui $s0, 100
ori $s1, $s0, 100
add $t0, $s0, $s1
ori $t0, $s0, 0
beq $t0, $s0, jump
beq $s0, $s1, jump2
return:
lui $s1, 0
ori $s1,$0, 0
add $s1, $s0, $s1
beq $s1, $s0, jump2
jump:
beq $s0, $t0, return
jump2:
```

下面是转换后的测试码：
```
v2.0 raw
3c100064
36110064
02114020
36080000
11100005
12110005
3c110000
34110000
02118820
12300001
1208fffb
```


## 思考题
---
1. **上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。**
		状态存储功能：IFU、IM、GRF、DM
		状态转移功能：IFU、NPC、ALU、Controller
2. **现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。**
		我觉得非常合理。因为IM是存储指令的，在指令执行过程中不可改变；而DM是存储数据的，有许多指令例如`sw`等能够修改DM内数据的值，所有用RAM可读又可写；而GRF寄存器，他不是按照地址储存的，并且他在改变值之后不需要找到之前的值用作返回，所以就选择Register。
3. **在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。**
		我设计了其他模块，例如NPC，参见上文的设计。
4. **事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？**
		因为nop对应的opcode是R型指令，而且对应的三个操作寄存器均为`$0`，`$0`不能够写入其他值，始终为0，所以就不需要考虑额外的控制信号来控制该指令。因为这个指令操作的寄存器不会有任何的效果。
5. **阅读 Pre 的[“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/)一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。**
		我觉得从单一指令的各种行为来说，覆盖情况算可以，但是一些指令类如`add`没有测试其边界值，没有边界数据对应的效果；但是综合起来，覆盖情况算可以，考虑到了不少的可能出现的情况。
		不足之处：我觉得`add`应该多一些对临界值的考虑；我觉得对于`lw`可以考虑其立即数超出了存储范围，但是经过运算减法之后还在存储范围内这一情况；对于`beq`，可以考虑各种指令的跳转情况，可以考虑在该指令前中后分别进行能否跳转的测试。


## P3课下心得
---
这次课下对我来说可以说是十分艰难，我总结出了许多错误教训供课上参考：
1. 首先，不要心急，一定要读明白这个指令是如何进行运算的，不要一上来就自以为是什么什么信号；
2. 其次，一定要搞清楚有哪些控制信号，尽量一条指令只添加一个控制信号，控制信号多了反而影响观感不易debug；
3. 然后，遇到bug一定不要心急，一定要沉住气，看看错误可能出现在哪些地方，是逻辑错误还是一个小小的器件弄错了。
4. 最后，我觉得一定要再加深对CPU的理解，理解单周期CPU的工作原理，那么这些应该都不是问题，稳住，加油！